# High Level Language instructions

*Published 2005-03-29*

Wayback machine: https://web.archive.org/web/20140214162851/http://osix.net/modules/article/?id=676

> You may already know that there is no instruction like [if, then, else] or [for, while, case]...etc in assembly.
> Here we're going to see 3 things:
> - the HLA syntax (high level assembly available in mASM)
> - how to implement them in pure assembly
> - and what is the code generated by those HLA instructions.


## Introduction:

HLA has a lot of advantages, it reduces the size of your source considerably, it makes your program easier to debug, it allows you to add more code, conditions, loops without modifying the whole thing and it is a good help for beginners who want to learn assembly.

The only inconvenient I would think of is that your asm source looses some of its "magic" that made the assembly language famous.

For each of the 3 instructions below, I'm going to give you the equivalent in assembly, HLA and the code generated by the compiler. (to see in a debugger).


- If, Then, Else
- while
- Repeat

**NOTE**: When I say _HLA_, I'm only refering to the 3 above instructions. The _real_ High Language Assembly developped by Randall Hyde looks more like a scripting language and, in my humble opinion, has nothing to do with assembly.

Example:

```
program myProg;
#include("stdlib.hhf");

begin GetMsg;
  stdout.put( "Enter an integer value: " );
  stdin.get( MyVar );
  stdout.put( "You entered: ", MyVar, nl );
end GetMsg;
```

## Part1: If then Else

### a - One possible translation in assembly

_pseudo code:_
If ax=1 then bx=2
else bx=0 and cx=2

```
if1:
  CMP ax,1
  JNZ else1
then1:
  MOV bx,2
  JMP endif1
else1:
  MOV bx,0
  MOV cx,2
endif:
```

### b - The HLA syntax

```
.IF ax==1
  MOV bx,2
.ELSE
  MOV bx,0
  MOV cx,2
.ENDIF
```

There's not much to comment here. You see that the _HLA_ code is a lot easier to handle and reduces the source largely.

### c - The disasembly

Now let's see what mASM generates for this code:

```
.486
.model flat, stdcall
option casemap:none

.code
start:
xor eax,eax
xor ebx,ebx
xor ecx,ecx
.IF ax==1
  MOV bx,2
.ELSE
  MOV bx,0
  MOV cx,2
.ENDIF
end start
```

disasembly:

```
00401000 XOR EAX,EAX
00401002 XOR EBX,EBX
00401004 XOR ECX,ECX
00401006 CMP AX,1
0040100A JNZ SHORT 00401012
0040100C MOV BX,2
00401010 JMP SHORT 0040101A
00401012 MOV BX,0
00401016 MOV CX,2
```

Very good! It's exactly the same code we would have written in pure assembly.
My conclusion: use .IF .ELSE :o)
Follow [this link](https://web.archive.org/web/20140214162851/http://webster.cs.ucr.edu/AoA/DOS/ch08/CH08-6.html) for more informations on the if statement in HLA.

## Part2: While

### a - One possible translation in assembly

_pseudo code:_
While cx < 10
ax+=1

```
while1:
  CMP cx,10
  JGE endwhile1
  INC ax
  INC cx
  JMP while1
endwhile1:
```

### b - The HLA syntax

```
.486
.model flat, stdcall
option casemap:none

.code
start:
xor eax,eax
xor ecx,ecx
  .WHILE cx < 10
    inc ax
    inc cx
  .ENDW
end start
```

### c - The disasembly

```
00401000 XOR EAX,EAX
00401002 XOR ECX,ECX
00401004 JMP SHORT 0040100B
00401006 INC AX
0040100A INC ECX
0040100B CMP ECX,0A
0040100E JB SHORT 00401006
```

Here again nothing special, the code is roughly the same except for the JMP. In my code, for each loop, I use 2 jumps (JMP and JGE) In the code generated by mASM, the first JMP is used only once, so for each loop, only 1 jump is used which reduces the 'execution time' (I'm planning to write something about code optimization).
Here again, mASM generated the most optimized code possible.

## Part3: Repeat

### a - One possible translation in assembly

_pseudo code:_
bx=10
repeat: bx-=bx
until bx=0

```
MOV bx,10
repeat1:
  DEC bx
  CMP bx,0
  JG repeat1
enrepeat1:
```

### b - The HLA syntax

```
.486
.model flat, stdcall
option casemap:none

.code
start:
xor ebx,ebx
xor ecx,ecx
mov bx,10
  .REPEAT
    dec bx
  .UNTIL bx==0
end start
```


### c - The disasembly

```
00401004 MOV BX,0A
00401008 DEC BX
0040100A OR BX,BX
0040100D JNZ SHORT 00401008
```

Here we see a difference. mASM replaced our CMP by OR which reduced our code by 1 byte :p (3 bytes for CMP against 2 bytes for OR).

> Q - "why didn't it replaced the other CMP in the previous examples?".

> A - it works only in replacement of CMP reg,0

If you OR a register with itself, the Zero Flag will be set to
**0 if reg!=0**

and it will be set to
**1 if reg=0**.

Then you can check the flag with a JNE, JE...etc.

## Conclusion:

I'm not sure what to deduce from this article... It was just to give something to read about assembly, but _a posteriori_, mASM users may find something to reply to those _assembly purists_ who thinks mASM is a tool with which you don't code real assembly.

mASM is an assembler. You can use whatever syntax you want, from the lowest possible to the highest (see example at the begining of the article). Now this assembler provides some useful features to make your source code more readable, clean and easily debuggable and I personaly won't give up the above 3 useful instructions unless I'm given another assembler or another OS.

[Click here](https://web.archive.org/web/20140214162851/http://www.masm32.com/masmmyth.htm) for more information on popular beliefs about mASM.