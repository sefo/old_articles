# Compiled arithmetic

*Published 2005-06-21*

Wayback machine: https://web.archive.org/web/20140214163503/http://osix.net/modules/article/?id=707

> This article is a complement to TroPe's article "Arithmetic in Assembly".

We are going to analyze the code generated by a compiler and see how arithmetic operations (such as x\*=32 for example) are implemented in assembly.

## ::lcc examples::

Let's take look at how lcc generates basic arithmetic instructions for this code:

```
#include <stdio.h>

int main (void) {
  int a=3;
  int b=6;
  int c=b;
  int d=0;
  int e=d;

  a*=b;
  c=a*b;
  b*=3;
  a=b*2;
  b=2*3;
  e*=d;
}
```

### a/ Initializing variables:

```
MOV DWORD PTR SS:[EBP-8],3 ;a=3
MOV DWORD PTR SS:[EBP-4],6 ;b=6
```

We notice that lcc uses the stack to store our global variables.
The stack is usually used for temporary variables.
The opcode used to initialize the variables with an integer is obviously _MOV_.

```
MOV EDI,DWORD PTR SS:[EBP-4]
MOV DWORD PTR SS:[EBP-14],EDI
```

_c=b_
Since lcc uses the stack to store the variables, it cannot address another variable directly, it has to use an intermediary register (EDI).

`MOV DWORD PTR SS:[EBP-C],0 ;d=0`

Here again _XOR_ would have been the instruction of choice to initialize a variable to 0.
But the use of the stack prevents its direct use.

```
MOV EDI,DWORD PTR SS:[EBP-C]
MOV DWORD PTR SS:[EBP-10],EDI
```

_c=d_

### b/ Basic arithmetic:

```
MOV EDI,DWORD PTR SS:[EBP-8]
IMUL EDI,DWORD PTR SS:[EBP-4]
MOV DWORD PTR SS:[EBP-8],EDI
MOV EDI,DWORD PTR SS:[EBP-8]
IMUL EDI,DWORD PTR SS:[EBP-4]
MOV DWORD PTR SS:[EBP-14],EDI
IMUL EDI,DWORD PTR SS:[EBP-4],3
MOV DWORD PTR SS:[EBP-4],EDI
```

_a*=b_ and _c=a*b_ and _b*=3_

Nothing particular here. The obvious _IMUL_ is used.

```
MOV EDI,DWORD PTR SS:[EBP-4]
SHL EDI,1
MOV DWORD PTR SS:[EBP-8],EDI
```

_a=b*2_

Here the compiler generated some clever code.
The opcode for _IMUL_ is not only 4 bytes big, but it's also very slow.
Compilers will always try to find an alternative to replace it.
Here it shifts EDI 1 byte to the left which is the equivalent of a multiplication by 2.
_SHL_ is often used by compilers to replace multiplications or divisions. It's opcode is small and it's very cheap on clock cycles.

`MOV DWORD PTR SS:[EBP-4],6`

_b=2*3_

Another clever trick here.
lcc calculated 2*3 at compilation time and only generated the code `MOV memory, 6` which saves some space and clock cycles.

```
MOV EDI,DWORD PTR SS:[EBP-10]
IMUL EDI,DWORD PTR SS:[EBP-C]
MOV DWORD PTR SS:[EBP-10],EDI
```

_e*=d_

Surprisingly no clever trick for a multiplication by zero, but a simple _IMUL_

## ::bcc examples::

For the same code, I tried and used Borland's compiler to see if it generated a different code.
It appears that bcc uses a completely different logic.
It doesn't separate the variables initialization from the code itself and creates several _CALL_s for each operation.

```
MOV EDX,3
MOV EAX,6
XOR ECX,ECX
IMUL EDX,EAX
LEA EDX,DWORD PTR DS:[EAX+EAX*2]
MOV EAX,EDX
```

In the first _CALL_ we have at the same time the initialization of _a_ and _b_ and 2 operations:

_a*=b_ and _c=a*b_

The advantage in the generated code is the use of plain registers instead of the stack. It saves a lot space and speed.
The initialization of 2 variables with integer values is done with the obvious _MOV_ instruction.

_a*=b_ is also simply done using _IMUL EDX,EAX_

Now let's take a look at how _c=a*b_ has been changed into `LEA EDX,DWORD PTR DS:[EAX+EAX*2]`

This instruction loads into EDX the value of EAX*2 + EAX (which is EAX*3)
EAX being equal to 6, c=3*6 or c=a*b has been calculated in a single line instead of 3 lines for lcc!
The use of _LEA_ and registers is an advantage because we can use direct addressing.

I jump over the rest of the code since it's essentially similar to lcc at the difference that it uses registers directly.

## More examples:

### ::Multiplication ::

We've seen in the previous section that most multiplications are performed using _IMUL_ (or MUL).
But compilers always try to avoid this instruction when 1 variable is multiplied by a constant.
Depending on the compiler and its level of optimization, the generated code can be completely different.
We've already seen that a multiplication by 2 can be translated by `SHL EAX, 1`.

For a multiplication by 3 we can have 4 different cases:

`IMUL EAX, 3`

Which will most likely never be used by a compiler. (opcode size and clock cycles)

```
ADD EAX, EAX
ADD EAX, EAX
ADD EAX, EAX
```

Not particularly pretty, this code is nevertheless faster than IMUL.

```
MOV ESI, EAX
SHL EAX, 1
ADD EAX, ESI
```

This is the code generated by most compilers.

`LEA EAX, DWORD PTR [EAX+EAX*2]`

Fast, small and 1 line of code.

Let's take a look at a slightly more complicated operation, a multiplication by 32.
The obvious way to do this without using IMUL (and what lcc produces) is:

`SHL EAX, 5`

Note: _You can use SHL to multiply a number as follows:
SHL1 will multiply by 2, SHL2 by 4, SHL3 by 8, SHL4 by 16...etc._

Some more optimized compilers generate this:

```
LEA EAX, DWORD PTR [EBX+EBX]
ADD EAX, EAX
ADD EAX, EAX
ADD EAX, EAX
ADD EAX, EAX
```

This is the quivalent of y=x*2*2*2*2*2 or y=x*32
In term of size it is surprising that a compiler generates this code.
But SHL has a latency of 4 clock cycles whereas this combination of LEA and ADD could be executed in 3 clock cycles.

Let's take a look at this last example of optimized multiplication:

_y = (x+x*4)*5-x_

Can be translated into:

```
MOV ESI, EAX
SHL EAX, 2 ; x*4
ADD EAX, ESI ; +x
LEA EAX, DWORD PTR [EAX+EAX*4] ; *5
SUB EAX, ESI ; -x
```

## Conclusion:

A combination of _SHL_, _LEA_ and low latency instructions such as _ADD_ or _SUB_ can be used in complicated equations or big calculations to optimize the speed and the size of your code.
It is also a good way to obfuscate your program and your encryption functions.
Divisions can be treated in a similar way but it is a subject a little more complicated and will be dealed in a future article.